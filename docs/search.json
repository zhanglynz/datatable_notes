[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Learning data.table Notes",
    "section": "",
    "text": "Preface\nMy notes on learning data.table.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#basics",
    "href": "index.html#basics",
    "title": "Learning data.table Notes",
    "section": "Basics",
    "text": "Basics\n\ndata.table()\n\n\nlibrary(data.table)\nsmall_dtb &lt;- data.table(x = letters[1:5],\n                        y = rnorm(5),\n                        z = 1:5)\nsmall_dtb\n\n        x          y     z\n   &lt;char&gt;      &lt;num&gt; &lt;int&gt;\n1:      a  0.7483929     1\n2:      b  0.4520126     2\n3:      c  1.2175161     3\n4:      d  1.4380206     4\n5:      e -0.3924529     5\n\n\n\nYou can also convert existing objects to a data.table using setDT() (for data.frame and list structures) or as.data.table() (for other structures).\n\n\ngeneral form DT[i, j, by] — Take DT, subset/reorder rows using i, then calculate j, grouped by by.\nsubset rows in i\n\nExample:\n\n(small_dtb[x %in% c('a', 'b', 'c', 'e') & z &gt;= 3])\n\n        x          y     z\n   &lt;char&gt;      &lt;num&gt; &lt;int&gt;\n1:      c  1.2175161     3\n2:      e -0.3924529     5\n\n\nExample:\n\n(small_dtb[c(2, 5)])\n\n        x          y     z\n   &lt;char&gt;      &lt;num&gt; &lt;int&gt;\n1:      b  0.4520126     2\n2:      e -0.3924529     5\n\n\nup to – Sort flights first by column origin in ascending order, and then by dest in descending order:",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction to data.table",
    "section": "",
    "text": "1.1 Basics\nlibrary(data.table)\n\nset.seed(12345)\n\nsmall_dtb &lt;- data.table(x = letters[1:5],\n                        y = rnorm(5),\n                        z = 1:5)\nsmall_dtb\n\n        x          y     z\n   &lt;char&gt;      &lt;num&gt; &lt;int&gt;\n1:      a  0.5855288     1\n2:      b  0.7094660     2\n3:      c -0.1093033     3\n4:      d -0.4534972     4\n5:      e  0.6058875     5\nExample:\n(small_dtb[x %in% c('a', 'b', 'c', 'e') & z &gt;= 3])\n\n        x          y     z\n   &lt;char&gt;      &lt;num&gt; &lt;int&gt;\n1:      c -0.1093033     3\n2:      e  0.6058875     5\nExample:\n(small_dtb[c(2, 5)])\n\n        x         y     z\n   &lt;char&gt;     &lt;num&gt; &lt;int&gt;\n1:      b 0.7094660     2\n2:      e 0.6058875     5\nExample:\n# x in in descending order; and then y in ascending order\n(small_dtb[order(-x, y)])\n\n        x          y     z\n   &lt;char&gt;      &lt;num&gt; &lt;int&gt;\n1:      e  0.6058875     5\n2:      d -0.4534972     4\n3:      c -0.1093033     3\n4:      b  0.7094660     2\n5:      a  0.5855288     1\nExample:\n(small_dtb[, .(x, z)])\n\n        x     z\n   &lt;char&gt; &lt;int&gt;\n1:      a     1\n2:      b     2\n3:      c     3\n4:      d     4\n5:      e     5\nExample:\n# select and rename\n(small_dtb[, .(x_1 = x, z)])\n\n      x_1     z\n   &lt;char&gt; &lt;int&gt;\n1:      a     1\n2:      b     2\n3:      c     3\n4:      d     4\n5:      e     5\nExample:\n# return a vector\n(small_dtb[, z])\n\n[1] 1 2 3 4 5\nExample:\n(small_dtb)\n\n        x          y     z\n   &lt;char&gt;      &lt;num&gt; &lt;int&gt;\n1:      a  0.5855288     1\n2:      b  0.7094660     2\n3:      c -0.1093033     3\n4:      d -0.4534972     4\n5:      e  0.6058875     5\n\n(chk &lt;- small_dtb[, sum(y + z &gt; 3)])\n\n[1] 2\nExample:\n(small_dtb[x %in% letters[2:4], sum(y + z &gt; 3)])\n\n[1] 1\nExample:\n(small_dtb[x %in% letters[2:4], .(mean_1 = mean(y), mean_2 = mean(z))])\n\n       mean_1 mean_2\n        &lt;num&gt;  &lt;num&gt;\n1: 0.04888851      3\nExample:\n(small_dtb[x %in% c('a', 'c', 'f') & y &gt; 0, .N])\n\n[1] 1\nExample:\nsel_vars &lt;- c('x', 'z')\n(small_dtb[, sel_vars, with = FALSE])\n\n        x     z\n   &lt;char&gt; &lt;int&gt;\n1:      a     1\n2:      b     2\n3:      c     3\n4:      d     4\n5:      e     5\nExample:\n(small_dtb[, -c('x', 'z')])\n\n            y\n        &lt;num&gt;\n1:  0.5855288\n2:  0.7094660\n3: -0.1093033\n4: -0.4534972\n5:  0.6058875\n\n(small_dtb[, !c('x', 'z')])\n\n            y\n        &lt;num&gt;\n1:  0.5855288\n2:  0.7094660\n3: -0.1093033\n4: -0.4534972\n5:  0.6058875\nExample:\n(small_dtb[, y:z])\n\n            y     z\n        &lt;num&gt; &lt;int&gt;\n1:  0.5855288     1\n2:  0.7094660     2\n3: -0.1093033     3\n4: -0.4534972     4\n5:  0.6058875     5",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to data.table</span>"
    ]
  },
  {
    "objectID": "intro.html#basics",
    "href": "intro.html#basics",
    "title": "1  Introduction to data.table",
    "section": "",
    "text": "data.table()\n\n\n\nYou can also convert existing objects to a data.table using setDT() (for data.frame and list structures) or as.data.table() (for other structures).\n\n\nGeneral form DT[i, j, by] — Take DT, subset/reorder rows using i, then calculate j, grouped by by.\nSubset rows in i\n\n\n\n\n\n\nOrder rows\n\n\n\n\nSelect column(s) in j\n\n\n\n\nTip: As long as j-expression returns a list, each element of the list will be converted to a column in the resulting data.table.\n\n\n\n\n\n\nCompute or do in j\n\n\n\n\nSubset in i and do in j\n\n\n\n\n\n\nSpecial symbol .N\n\n\n.N is a special built-in variable that holds the number of observations in the current group.\n\n\n\n\nSelect columns named in a variable using with = FALSE\n\n\n\n\nDeselect columns using - or !\n\n\n\n\nSelect by specifying start and end column names (From version 1.9.5+)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to data.table</span>"
    ]
  },
  {
    "objectID": "intro.html#aggregations",
    "href": "intro.html#aggregations",
    "title": "1  Introduction to data.table",
    "section": "1.2 Aggregations",
    "text": "1.2 Aggregations\n\n# create a data.table \nset.seed(98765)\n\ndt &lt;- data.table(ID = sprintf(\"%03d\", 1L:100L))\ndt[, `:=`(x = sample(letters[1:3],   length(ID), replace = TRUE),\n          y = sample(month.abb, length(ID), replace = TRUE),\n          w = runif(length(ID)),\n          z = rnorm(length(ID))\n         )]\n\nExample:\n\n(dt[, .(.N), by = y][order(match(y, month.abb))]) # nice!\n\n         y     N\n    &lt;char&gt; &lt;int&gt;\n 1:    Jan     9\n 2:    Feb     6\n 3:    Mar    10\n 4:    Apr     8\n 5:    May     8\n 6:    Jun     6\n 7:    Jul     9\n 8:    Aug     8\n 9:    Sep    13\n10:    Oct     5\n11:    Nov    10\n12:    Dec     8\n\n# or (useful for coding programmatically)\n(dt[, .(.N), by = \"y\"][order(match(y, month.abb))]) \n\n         y     N\n    &lt;char&gt; &lt;int&gt;\n 1:    Jan     9\n 2:    Feb     6\n 3:    Mar    10\n 4:    Apr     8\n 5:    May     8\n 6:    Jun     6\n 7:    Jul     9\n 8:    Aug     8\n 9:    Sep    13\n10:    Oct     5\n11:    Nov    10\n12:    Dec     8\n\n\nExample:\n\n(dt[, .(.N), by = .(y, x)][order(match(y, month.abb), x)])\n\n         y      x     N\n    &lt;char&gt; &lt;char&gt; &lt;int&gt;\n 1:    Jan      a     2\n 2:    Jan      b     3\n 3:    Jan      c     4\n 4:    Feb      a     2\n 5:    Feb      b     1\n 6:    Feb      c     3\n 7:    Mar      a     2\n 8:    Mar      b     5\n 9:    Mar      c     3\n10:    Apr      a     4\n11:    Apr      b     1\n12:    Apr      c     3\n13:    May      a     2\n14:    May      b     5\n15:    May      c     1\n16:    Jun      a     2\n17:    Jun      b     4\n18:    Jul      a     2\n19:    Jul      b     4\n20:    Jul      c     3\n21:    Aug      a     4\n22:    Aug      b     3\n23:    Aug      c     1\n24:    Sep      a     2\n25:    Sep      b     4\n26:    Sep      c     7\n27:    Oct      a     3\n28:    Oct      b     2\n29:    Nov      a     4\n30:    Nov      b     2\n31:    Nov      c     4\n32:    Dec      a     2\n33:    Dec      b     3\n34:    Dec      c     3\n         y      x     N\n\n\n\nMultiple columns in j — .SD (Subset of Data)\n\n\n.SD contains all the columns except the grouping columns by default.\n\nExample:\n\n(dt[, lapply(.SD, dplyr::n_distinct), by = y][\n  order(match(y, month.abb))\n])\n\n         y    ID     x     w     z\n    &lt;char&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;\n 1:    Jan     9     3     9     9\n 2:    Feb     6     3     6     6\n 3:    Mar    10     3    10    10\n 4:    Apr     8     3     8     8\n 5:    May     8     3     8     8\n 6:    Jun     6     2     6     6\n 7:    Jul     9     3     9     9\n 8:    Aug     8     3     8     8\n 9:    Sep    13     3    13    13\n10:    Oct     5     2     5     5\n11:    Nov    10     3    10    10\n12:    Dec     8     3     8     8\n\n\n\nSpecify just the columns — .SDcols\n\nExample:\n\n(dt[, lapply(.SD, mean), by = y, .SDcols = c(\"w\", \"z\")][\n  order(match(y, month.abb))])\n\n         y         w           z\n    &lt;char&gt;     &lt;num&gt;       &lt;num&gt;\n 1:    Jan 0.5971593  0.28410248\n 2:    Feb 0.5989121 -0.67326526\n 3:    Mar 0.4746379 -0.12092181\n 4:    Apr 0.5588728 -0.13687424\n 5:    May 0.6600847  0.46348110\n 6:    Jun 0.4236736 -0.50359112\n 7:    Jul 0.4167678  0.25590180\n 8:    Aug 0.3144608 -0.07113313\n 9:    Sep 0.5571863 -0.39837109\n10:    Oct 0.4690520 -0.31808535\n11:    Nov 0.3810588  0.13124172\n12:    Dec 0.3255893  0.45452864\n\n\n\nSubset .SD for each group\n\nExample:\n\n(dt[, head(.SD, 2), by = y][\n  order(match(y, month.abb))]\n)\n\n         y     ID      x          w           z\n    &lt;char&gt; &lt;char&gt; &lt;char&gt;      &lt;num&gt;       &lt;num&gt;\n 1:    Jan    013      b 0.36384835  0.25820390\n 2:    Jan    032      c 0.41055509  1.58401597\n 3:    Feb    001      c 0.86811462 -2.28932905\n 4:    Feb    022      c 0.54402505 -1.03936619\n 5:    Mar    002      a 0.73088424  0.49876437\n 6:    Mar    006      b 0.66991774  0.28428795\n 7:    Apr    008      c 0.30558214 -1.29345693\n 8:    Apr    015      b 0.61864358  1.53498830\n 9:    May    017      b 0.98673557  0.14859075\n10:    May    028      b 0.82192736  0.39779991\n11:    Jun    026      a 0.63850907 -0.89876505\n12:    Jun    031      b 0.60116673  0.04881219\n13:    Jul    009      c 0.51579622  1.14680667\n14:    Jul    019      a 0.73327795  1.65312728\n15:    Aug    010      c 0.35723023  1.13575657\n16:    Aug    029      a 0.05977576 -0.09744826\n17:    Sep    003      c 0.99907046 -1.80143219\n18:    Sep    014      a 0.25378696 -0.34646956\n19:    Oct    018      a 0.66016728 -0.30006219\n20:    Oct    025      a 0.08602937  0.11936690\n21:    Nov    005      a 0.85700207 -1.31407637\n22:    Nov    021      b 0.39336712  0.60190574\n23:    Dec    004      b 0.09781495  2.03149960\n24:    Dec    011      c 0.10491620 -0.42566702\n         y     ID      x          w           z\n\n\n\nMake ‘longer’ table — melt\n\n\nfk_data &lt;- data.table(week = 1:5,\n                      player_1 = rnorm(5),\n                      player_2 = rnorm(5))\nlong_tb &lt;- melt(fk_data,\n                measure.vars = c(\"player_1\", \"player_2\"),\n                variable.name = \"player\",\n                value.name = \"value\")\n(long_tb)\n\n     week   player      value\n    &lt;int&gt;   &lt;fctr&gt;      &lt;num&gt;\n 1:     1 player_1  0.9842654\n 2:     2 player_1  0.1542017\n 3:     3 player_1 -0.7450324\n 4:     4 player_1 -0.2477755\n 5:     5 player_1  0.4545554\n 6:     1 player_2 -0.3609907\n 7:     2 player_2  0.4675788\n 8:     3 player_2  1.4384395\n 9:     4 player_2 -0.1420841\n10:     5 player_2 -1.4523287\n\n\n\nMake ‘wider’ table — dcast\n\n\n# add row id\n# long_tb[, id := sample(1:5), by = player][, id := paste0('wk_', id)]\n\nwide_tb &lt;- dcast(\n  long_tb,\n  week ~ player,\n  value.var = \"value\"\n)\n(wide_tb)\n\nKey: &lt;week&gt;\n    week   player_1   player_2\n   &lt;int&gt;      &lt;num&gt;      &lt;num&gt;\n1:     1  0.9842654 -0.3609907\n2:     2  0.1542017  0.4675788\n3:     3 -0.7450324  1.4384395\n4:     4 -0.2477755 -0.1420841\n5:     5  0.4545554 -1.4523287",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to data.table</span>"
    ]
  },
  {
    "objectID": "reference_semantics.html",
    "href": "reference_semantics.html",
    "title": "2  Reference semantics",
    "section": "",
    "text": "2.1 Syntax\nThe LHS := RHS form\nDT[, c(\"colA\", \"colB\", ...) := list(valA, valB, ...)]\n# when you have only one column to assign to you\n# can drop the quotes and list(), for convenience\nDT[, colA := valA]\nThe functional form\nDT[, `:=`(colA = valA, # valA is assigned to colA\n          colB = valB, # valB is assigned to colB\n         )\n  ]",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Reference semantics</span>"
    ]
  },
  {
    "objectID": "reference_semantics.html#syntax",
    "href": "reference_semantics.html#syntax",
    "title": "2  Reference semantics",
    "section": "",
    "text": "In “LHS := RHS form”, LHS takes a character vector of column names and RHS a list of values. RHS just needs to be a list, irrespective of how its generated (e.g., using lapply(), list(), mget(), mapply() etc.). This form is usually easy to program with and is particularly useful when you don’t know the columns to assign values to in advance.\n\n\n\n\nIn the two forms of := shown above, note that we don’t assign the result back to a variable. Because we don’t need to. The input data.table is modified by reference.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Reference semantics</span>"
    ]
  },
  {
    "objectID": "reference_semantics.html#examples",
    "href": "reference_semantics.html#examples",
    "title": "2  Reference semantics",
    "section": "2.2 Examples",
    "text": "2.2 Examples\n\nAdd columns by reference\n\n\nlibrary(data.table)\n\ndt_0 &lt;- data.table(ID = sprintf(\"%02d\", 1:15),\n                   u = letters[1:15],\n                   v = month.name,\n                   w = runif(15),\n                   x = rnorm(15))\n(dt_0)\n\n        ID      u         v          w            x\n    &lt;char&gt; &lt;char&gt;    &lt;char&gt;      &lt;num&gt;        &lt;num&gt;\n 1:     01      a   January 0.64367142 -0.422827306\n 2:     02      b  February 0.38118787 -2.160689919\n 3:     03      c     March 0.15343236 -0.350000915\n 4:     04      d     April 0.60357175 -0.857870503\n 5:     05      e       May 0.24245114 -0.045487349\n 6:     06      f      June 0.15376619 -0.916804282\n 7:     07      g      July 0.95334494 -0.364791045\n 8:     08      h    August 0.20345150  0.190161111\n 9:     09      i September 0.05059934 -0.005576393\n10:     10      j   October 0.28211980 -0.151163262\n11:     11      k  November 0.78676139  1.266540033\n12:     12      l  December 0.75357142 -1.338475490\n13:     13      m   January 0.50718585  1.157909403\n14:     14      n  February 0.20883600  0.290874294\n15:     15      o     March 0.39658656 -0.447705168\n\ndt_0[, x_1 := (x - mean(x)) / sd(x)][]\n\n        ID      u         v          w            x         x_1\n    &lt;char&gt; &lt;char&gt;    &lt;char&gt;      &lt;num&gt;        &lt;num&gt;       &lt;num&gt;\n 1:     01      a   January 0.64367142 -0.422827306 -0.16743812\n 2:     02      b  February 0.38118787 -2.160689919 -2.16367012\n 3:     03      c     March 0.15343236 -0.350000915 -0.08378458\n 4:     04      d     April 0.60357175 -0.857870503 -0.66715953\n 5:     05      e       May 0.24245114 -0.045487349  0.26600126\n 6:     06      f      June 0.15376619 -0.916804282 -0.73485504\n 7:     07      g      July 0.95334494 -0.364791045 -0.10077357\n 8:     08      h    August 0.20345150  0.190161111  0.53668376\n 9:     09      i September 0.05059934 -0.005576393  0.31184580\n10:     10      j   October 0.28211980 -0.151163262  0.14461442\n11:     11      k  November 0.78676139  1.266540033  1.77308876\n12:     12      l  December 0.75357142 -1.338475490 -1.21921643\n13:     13      m   January 0.50718585  1.157909403  1.64830793\n14:     14      n  February 0.20883600  0.290874294  0.65237004\n15:     15      o     March 0.39658656 -0.447705168 -0.19601460\n\n\n\ndt_0[, w_1 := ifelse(w &gt; 0.5, w + 1, w)][]\n\n        ID      u         v          w            x         x_1        w_1\n    &lt;char&gt; &lt;char&gt;    &lt;char&gt;      &lt;num&gt;        &lt;num&gt;       &lt;num&gt;      &lt;num&gt;\n 1:     01      a   January 0.64367142 -0.422827306 -0.16743812 1.64367142\n 2:     02      b  February 0.38118787 -2.160689919 -2.16367012 0.38118787\n 3:     03      c     March 0.15343236 -0.350000915 -0.08378458 0.15343236\n 4:     04      d     April 0.60357175 -0.857870503 -0.66715953 1.60357175\n 5:     05      e       May 0.24245114 -0.045487349  0.26600126 0.24245114\n 6:     06      f      June 0.15376619 -0.916804282 -0.73485504 0.15376619\n 7:     07      g      July 0.95334494 -0.364791045 -0.10077357 1.95334494\n 8:     08      h    August 0.20345150  0.190161111  0.53668376 0.20345150\n 9:     09      i September 0.05059934 -0.005576393  0.31184580 0.05059934\n10:     10      j   October 0.28211980 -0.151163262  0.14461442 0.28211980\n11:     11      k  November 0.78676139  1.266540033  1.77308876 1.78676139\n12:     12      l  December 0.75357142 -1.338475490 -1.21921643 1.75357142\n13:     13      m   January 0.50718585  1.157909403  1.64830793 1.50718585\n14:     14      n  February 0.20883600  0.290874294  0.65237004 0.20883600\n15:     15      o     March 0.39658656 -0.447705168 -0.19601460 0.39658656\n\n\n\nDelete column by reference\n\n\ndt_0[, w := NULL][]\n\n        ID      u         v            x         x_1        w_1\n    &lt;char&gt; &lt;char&gt;    &lt;char&gt;        &lt;num&gt;       &lt;num&gt;      &lt;num&gt;\n 1:     01      a   January -0.422827306 -0.16743812 1.64367142\n 2:     02      b  February -2.160689919 -2.16367012 0.38118787\n 3:     03      c     March -0.350000915 -0.08378458 0.15343236\n 4:     04      d     April -0.857870503 -0.66715953 1.60357175\n 5:     05      e       May -0.045487349  0.26600126 0.24245114\n 6:     06      f      June -0.916804282 -0.73485504 0.15376619\n 7:     07      g      July -0.364791045 -0.10077357 1.95334494\n 8:     08      h    August  0.190161111  0.53668376 0.20345150\n 9:     09      i September -0.005576393  0.31184580 0.05059934\n10:     10      j   October -0.151163262  0.14461442 0.28211980\n11:     11      k  November  1.266540033  1.77308876 1.78676139\n12:     12      l  December -1.338475490 -1.21921643 1.75357142\n13:     13      m   January  1.157909403  1.64830793 1.50718585\n14:     14      n  February  0.290874294  0.65237004 0.20883600\n15:     15      o     March -0.447705168 -0.19601460 0.39658656\n\n\n\n:= along with grouping using by\n\n\ndt_1 &lt;- copy(dt_0)\ndt_2 &lt;- copy(dt_0)\n\ndt_1[, count := .N, by = v][] \n\n        ID      u         v            x         x_1        w_1 count\n    &lt;char&gt; &lt;char&gt;    &lt;char&gt;        &lt;num&gt;       &lt;num&gt;      &lt;num&gt; &lt;int&gt;\n 1:     01      a   January -0.422827306 -0.16743812 1.64367142     2\n 2:     02      b  February -2.160689919 -2.16367012 0.38118787     2\n 3:     03      c     March -0.350000915 -0.08378458 0.15343236     2\n 4:     04      d     April -0.857870503 -0.66715953 1.60357175     1\n 5:     05      e       May -0.045487349  0.26600126 0.24245114     1\n 6:     06      f      June -0.916804282 -0.73485504 0.15376619     1\n 7:     07      g      July -0.364791045 -0.10077357 1.95334494     1\n 8:     08      h    August  0.190161111  0.53668376 0.20345150     1\n 9:     09      i September -0.005576393  0.31184580 0.05059934     1\n10:     10      j   October -0.151163262  0.14461442 0.28211980     1\n11:     11      k  November  1.266540033  1.77308876 1.78676139     1\n12:     12      l  December -1.338475490 -1.21921643 1.75357142     1\n13:     13      m   January  1.157909403  1.64830793 1.50718585     2\n14:     14      n  February  0.290874294  0.65237004 0.20883600     2\n15:     15      o     March -0.447705168 -0.19601460 0.39658656     2\n\n\n\nMultiple columns and :=\n\n\nin_cols  = c(\"x\", \"w_1\")\nout_cols = c(\"max_x\", \"max_w_1\")\ndt_1[, new_grp := rep(LETTERS[1:3], each = 5)\n    ][, .(x, w_1, new_grp)][\n      , c(out_cols) := lapply(.SD, max), by = new_grp, .SDcols = in_cols\n      ][] # notice \"c(out_cols)\" instead of \"out_cols\"\n\n               x        w_1 new_grp       max_x  max_w_1\n           &lt;num&gt;      &lt;num&gt;  &lt;char&gt;       &lt;num&gt;    &lt;num&gt;\n 1: -0.422827306 1.64367142       A -0.04548735 1.643671\n 2: -2.160689919 0.38118787       A -0.04548735 1.643671\n 3: -0.350000915 0.15343236       A -0.04548735 1.643671\n 4: -0.857870503 1.60357175       A -0.04548735 1.643671\n 5: -0.045487349 0.24245114       A -0.04548735 1.643671\n 6: -0.916804282 0.15376619       B  0.19016111 1.953345\n 7: -0.364791045 1.95334494       B  0.19016111 1.953345\n 8:  0.190161111 0.20345150       B  0.19016111 1.953345\n 9: -0.005576393 0.05059934       B  0.19016111 1.953345\n10: -0.151163262 0.28211980       B  0.19016111 1.953345\n11:  1.266540033 1.78676139       C  1.26654003 1.786761\n12: -1.338475490 1.75357142       C  1.26654003 1.786761\n13:  1.157909403 1.50718585       C  1.26654003 1.786761\n14:  0.290874294 0.20883600       C  1.26654003 1.786761\n15: -0.447705168 0.39658656       C  1.26654003 1.786761\n\n# compare with dt_3\ndt_3 &lt;- \n  dt_2[, new_grp := rep(LETTERS[1:3], each = 5)\n      ][, lapply(.SD, max), by = new_grp, .SDcols = in_cols]\n(setnames(dt_3, in_cols, out_cols))\n\n   new_grp       max_x  max_w_1\n    &lt;char&gt;       &lt;num&gt;    &lt;num&gt;\n1:       A -0.04548735 1.643671\n2:       B  0.19016111 1.953345\n3:       C  1.26654003 1.786761\n\n\n\nHow can we update multiple existing columns in place using .SD?\n\n\ndt_3[, names(.SD) := lapply(.SD, as.character), .SDcols = is.numeric][]\n\n   new_grp               max_x          max_w_1\n    &lt;char&gt;              &lt;char&gt;           &lt;char&gt;\n1:       A -0.0454873490559889 1.64367142389528\n2:       B   0.190161111335384 1.95334493694827\n3:       C    1.26654003293267 1.78676139330491\n\n(dt_3[, lapply(.SD, function(x) paste0(x, \"_2026\")), \n      .SDcols = is.character])\n\n   new_grp                    max_x               max_w_1\n    &lt;char&gt;                   &lt;char&gt;                &lt;char&gt;\n1:  A_2026 -0.0454873490559889_2026 1.64367142389528_2026\n2:  B_2026   0.190161111335384_2026 1.95334493694827_2026\n3:  C_2026    1.26654003293267_2026 1.78676139330491_2026\n\n(dt_3)\n\n   new_grp               max_x          max_w_1\n    &lt;char&gt;              &lt;char&gt;           &lt;char&gt;\n1:       A -0.0454873490559889 1.64367142389528\n2:       B   0.190161111335384 1.95334493694827\n3:       C    1.26654003293267 1.78676139330491",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Reference semantics</span>"
    ]
  },
  {
    "objectID": "reference_semantics.html#andcopy",
    "href": "reference_semantics.html#andcopy",
    "title": "2  Reference semantics",
    "section": "2.3 :=andcopy()`",
    "text": "2.3 :=andcopy()`\n\n:= modifies the input object by reference. Apart from the features we have discussed already, sometimes we might want to use the update by reference feature for its side effect. And at other times it may not be desirable to modify the original object, in which case we can use copy() function, as we will see in a moment.\n\nExample:\n\n(dt_1)\n\n        ID      u         v           x         x_1        w_1 count new_grp\n    &lt;char&gt; &lt;char&gt;    &lt;char&gt;       &lt;num&gt;       &lt;num&gt;      &lt;num&gt; &lt;int&gt;  &lt;char&gt;\n 1:     01      a   January  1.61095311  1.52246017 0.36640648     2       A\n 2:     02      b  February  0.28500060  0.08452287 0.03026150     2       A\n 3:     03      c     March  1.71420451  1.63443178 1.73189933     2       A\n 4:     04      d     April -0.66211776 -0.94258541 0.31665220     1       A\n 5:     05      e       May  0.64469837  0.47459932 1.60921663     1       A\n 6:     06      f      June -0.87407021 -1.17243853 1.74539633     1       B\n 7:     07      g      July -0.27447155 -0.52220011 1.71124976     1       B\n 8:     08      h    August -0.07836709 -0.30953343 1.78824395     1       B\n 9:     09      i September  0.59936720  0.42543966 0.39686535     1       B\n10:     10      j   October  0.96864272  0.82590275 0.46928588     1       B\n11:     11      k  November -1.31463863 -1.65021564 1.89316502     1       C\n12:     12      l  December  0.77092541  0.61148700 0.22828796     1       C\n13:     13      m   January  0.75896271  0.59851397 1.52812948     2       C\n14:     14      n  February -0.02522628 -0.25190455 0.45504884     2       C\n15:     15      o     March -1.01795922 -1.32847985 0.09553725     2       C\n\nmy_fun_1 &lt;- function(a_dt)\n{a_dt[, the_sum := x_1 + w_1][\n      , .(the_max = max(the_sum)), by = new_grp]\n}\n\n(my_fun_1(dt_1))\n\n   new_grp  the_max\n    &lt;char&gt;    &lt;num&gt;\n1:       A 3.366331\n2:       B 1.478711\n3:       C 2.126643\n\n(names(dt_1))\n\n[1] \"ID\"      \"u\"       \"v\"       \"x\"       \"x_1\"     \"w_1\"     \"count\"  \n[8] \"new_grp\" \"the_sum\"\n\n# remove `the_sum` from dt_1\ndt_1[, the_sum := NULL]\n(names(dt_1))\n\n[1] \"ID\"      \"u\"       \"v\"       \"x\"       \"x_1\"     \"w_1\"     \"count\"  \n[8] \"new_grp\"\n\n# use copy()\nmy_fun_2 &lt;- function(a_dt)\n{a_dt &lt;- copy(a_dt)\n a_dt[, the_sum := x_1 + w_1][\n      , .(the_max = max(the_sum)), by = new_grp]\n}\n\n(my_fun_2(dt_1))\n\n   new_grp  the_max\n    &lt;char&gt;    &lt;num&gt;\n1:       A 3.366331\n2:       B 1.478711\n3:       C 2.126643\n\n(names(dt_1))\n\n[1] \"ID\"      \"u\"       \"v\"       \"x\"       \"x_1\"     \"w_1\"     \"count\"  \n[8] \"new_grp\"\n\n\n\nWhen we store the column names on to a variable, e.g., DT_n = names(DT), and then add/update/delete column(s) by reference. It would also modify DT_n, unless we do copy(names(DT)).\n\n\nDT &lt;- data.table(x = 1L, y = 2L)\n(DT_n  &lt;-  names(DT))\n\n[1] \"x\" \"y\"\n\n## add a new column by reference\nDT[, z := 3L][]\n\n       x     y     z\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;\n1:     1     2     3\n\n## DT_n also gets updated\n(DT_n)\n\n[1] \"x\" \"y\" \"z\"\n\n## use `copy()`\nDT_n = copy(names(DT))\nDT[, w := 4L]\n\n## DT_n doesn't get updated\n(DT_n)\n\n[1] \"x\" \"y\" \"z\"\n\n\n\nWhen you extract a single column as a vector, there is a subtle but important difference between standard R methods ($ and [[…]]) and data.table’s j expression. DT$col and DT[[‘col’]] may return a reference to the column, while DT[, col] always returns a copy.\n\nTo select a single column as a vector, remember:\n\nDT[, mycol] is safer as it always returns a new, independent copy.\nDT$mycol is fast but may return a reference. Use copy(DT$mycol) to guarantee independence.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Reference semantics</span>"
    ]
  },
  {
    "objectID": "reference_semantics.html#summary",
    "href": "reference_semantics.html#summary",
    "title": "2  Reference semantics",
    "section": "2.4 Summary",
    "text": "2.4 Summary\nThe := operator\n\nIt is used to add/update/delete columns by reference.\nWe can use := for its side effect or use copy() to not modify the original object while updating by reference.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Reference semantics</span>"
    ]
  },
  {
    "objectID": "reference_semantics.html#and-copy",
    "href": "reference_semantics.html#and-copy",
    "title": "2  Reference semantics",
    "section": "2.3 := and copy()",
    "text": "2.3 := and copy()\n\n:= modifies the input object by reference. Apart from the features we have discussed already, sometimes we might want to use the update by reference feature for its side effect. And at other times it may not be desirable to modify the original object, in which case we can use copy() function, as we will see in a moment.\n\nExample:\n\n(dt_1)\n\n        ID      u         v            x         x_1        w_1 count new_grp\n    &lt;char&gt; &lt;char&gt;    &lt;char&gt;        &lt;num&gt;       &lt;num&gt;      &lt;num&gt; &lt;int&gt;  &lt;char&gt;\n 1:     01      a   January -0.422827306 -0.16743812 1.64367142     2       A\n 2:     02      b  February -2.160689919 -2.16367012 0.38118787     2       A\n 3:     03      c     March -0.350000915 -0.08378458 0.15343236     2       A\n 4:     04      d     April -0.857870503 -0.66715953 1.60357175     1       A\n 5:     05      e       May -0.045487349  0.26600126 0.24245114     1       A\n 6:     06      f      June -0.916804282 -0.73485504 0.15376619     1       B\n 7:     07      g      July -0.364791045 -0.10077357 1.95334494     1       B\n 8:     08      h    August  0.190161111  0.53668376 0.20345150     1       B\n 9:     09      i September -0.005576393  0.31184580 0.05059934     1       B\n10:     10      j   October -0.151163262  0.14461442 0.28211980     1       B\n11:     11      k  November  1.266540033  1.77308876 1.78676139     1       C\n12:     12      l  December -1.338475490 -1.21921643 1.75357142     1       C\n13:     13      m   January  1.157909403  1.64830793 1.50718585     2       C\n14:     14      n  February  0.290874294  0.65237004 0.20883600     2       C\n15:     15      o     March -0.447705168 -0.19601460 0.39658656     2       C\n\nmy_fun_1 &lt;- function(a_dt)\n{a_dt[, the_sum := x_1 + w_1][\n      , .(the_max = max(the_sum)), by = new_grp]\n}\n\n(my_fun_1(dt_1))\n\n   new_grp  the_max\n    &lt;char&gt;    &lt;num&gt;\n1:       A 1.476233\n2:       B 1.852571\n3:       C 3.559850\n\n(names(dt_1))\n\n[1] \"ID\"      \"u\"       \"v\"       \"x\"       \"x_1\"     \"w_1\"     \"count\"  \n[8] \"new_grp\" \"the_sum\"\n\n# remove `the_sum` from dt_1\ndt_1[, the_sum := NULL]\n(names(dt_1))\n\n[1] \"ID\"      \"u\"       \"v\"       \"x\"       \"x_1\"     \"w_1\"     \"count\"  \n[8] \"new_grp\"\n\n# use copy()\nmy_fun_2 &lt;- function(a_dt)\n{a_dt &lt;- copy(a_dt)\n a_dt[, the_sum := x_1 + w_1][\n      , .(the_max = max(the_sum)), by = new_grp]\n}\n\n(my_fun_2(dt_1))\n\n   new_grp  the_max\n    &lt;char&gt;    &lt;num&gt;\n1:       A 1.476233\n2:       B 1.852571\n3:       C 3.559850\n\n(names(dt_1))\n\n[1] \"ID\"      \"u\"       \"v\"       \"x\"       \"x_1\"     \"w_1\"     \"count\"  \n[8] \"new_grp\"\n\n\n\nWhen we store the column names on to a variable, e.g., DT_n = names(DT), and then add/update/delete column(s) by reference. It would also modify DT_n, unless we do copy(names(DT)).\n\n\nDT &lt;- data.table(x = 1L, y = 2L)\n(DT_n  &lt;-  names(DT))\n\n[1] \"x\" \"y\"\n\n## add a new column by reference\nDT[, z := 3L][]\n\n       x     y     z\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;\n1:     1     2     3\n\n## DT_n also gets updated\n(DT_n)\n\n[1] \"x\" \"y\" \"z\"\n\n## use `copy()`\nDT_n = copy(names(DT))\nDT[, w := 4L]\n\n## DT_n doesn't get updated\n(DT_n)\n\n[1] \"x\" \"y\" \"z\"\n\n\n\nWhen you extract a single column as a vector, there is a subtle but important difference between standard R methods ($ and [[…]]) and data.table’s j expression. DT$col and DT[[‘col’]] may return a reference to the column, while DT[, col] always returns a copy.\n\nTo select a single column as a vector, remember:\n\nDT[, mycol] is safer as it always returns a new, independent copy.\nDT$mycol is fast but may return a reference. Use copy(DT$mycol) to guarantee independence.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Reference semantics</span>"
    ]
  },
  {
    "objectID": "keys_and_search.html",
    "href": "keys_and_search.html",
    "title": "3  Keys and fast binary search based subset",
    "section": "",
    "text": "3.1 Keys\nKeys and their properties",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Keys and fast binary search based subset</span>"
    ]
  },
  {
    "objectID": "keys_and_search.html#keys",
    "href": "keys_and_search.html#keys",
    "title": "3  Keys and fast binary search based subset",
    "section": "",
    "text": "data.tables never uses row names. Since data.tables inherit from data.frames, it still has the row names attribute. But it never uses them.\n\n\nIf you would like to preserve the row names, use keep.rownames = TRUE in as.data.table(a_df) - this will create a new column called rn and assign row names to this column.\n\n\nInstead, in data.tables we set and use keys. Think of a key as supercharged rownames.\n\n\n\nWe can set keys on multiple columns.\nUniqueness is not enforced, i.e., duplicate key values are allowed. Since rows are sorted by key, any duplicates in the key columns will appear consecutively.\nSetting a key does two things\n\nphysically reorders the rows of the data.table by the column(s) provided by reference, always in increasing order. (Since the rows are reordered, a data.table can have at most one key because it can not be sorted in more than one way.)\nmarks those columns as key columns by setting an attribute called sorted to the data.table.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Keys and fast binary search based subset</span>"
    ]
  },
  {
    "objectID": "keys_and_search.html#examples",
    "href": "keys_and_search.html#examples",
    "title": "3  Keys and fast binary search based subset",
    "section": "3.2 Examples",
    "text": "3.2 Examples\n\nlibrary(data.table)\n\nset.seed(12345)\nN &lt;- 1e6\ndt &lt;- data.table(x = sample(1:100, N, replace = TRUE),\n                 y = sample(letters, N, replace = TRUE),\n                 z = rnorm(N))\n\n(key(dt))\n\nNULL\n\n(t1 &lt;- system.time(ans1 &lt;- dt[x == 99 & y == 'a']))\n\n   user  system elapsed \n  0.035   0.007   0.028 \n\n(head(ans1))\n\n       x      y          z\n   &lt;int&gt; &lt;char&gt;      &lt;num&gt;\n1:    99      a  0.2081657\n2:    99      a  1.7643860\n3:    99      a -0.3033784\n4:    99      a -0.3410771\n5:    99      a -1.1956415\n6:    99      a  0.2045236\n\nsetkey(dt, x, y)\n(key(dt))\n\n[1] \"x\" \"y\"\n\n(t2 &lt;- system.time(ans2 &lt;- dt[.(99, 'a')]))\n\n   user  system elapsed \n  0.002   0.000   0.002 \n\n(head(ans2))\n\nKey: &lt;x, y&gt;\n       x      y          z\n   &lt;int&gt; &lt;char&gt;      &lt;num&gt;\n1:    99      a  0.2081657\n2:    99      a  1.7643860\n3:    99      a -0.3033784\n4:    99      a -0.3410771\n5:    99      a -1.1956415\n6:    99      a  0.2045236\n\n# try `mult`\n(dt[.(99, 'a'), mult = 'first'])\n\nKey: &lt;x, y&gt;\n       x      y         z\n   &lt;int&gt; &lt;char&gt;     &lt;num&gt;\n1:    99      a 0.2081657\n\n(dt[.(99, 'a'), mult = 'last'])\n\nKey: &lt;x, y&gt;\n       x      y        z\n   &lt;int&gt; &lt;char&gt;    &lt;num&gt;\n1:    99      a 1.523553\n\n# try `nomatch`\n(dt[.(101, 'a')])\n\nKey: &lt;x, y&gt;\n       x      y     z\n   &lt;int&gt; &lt;char&gt; &lt;num&gt;\n1:   101      a    NA\n\n## Default value for nomatch is NA. Setting nomatch = NULL skips queries with no matches.\n(dt[.(101, 'a'), nomatch = NULL])\n\nKey: &lt;x, y&gt;\nEmpty data.table (0 rows and 3 cols): x,y,z\n\n# remove the key\nsetkey(dt, NULL)\n\n\nKey based subsets are incredibly fast and are particularly useful when the task involves repeated subsetting. But it may not be always desirable to set key and physically reorder the data.table.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Keys and fast binary search based subset</span>"
    ]
  },
  {
    "objectID": "examples.html",
    "href": "examples.html",
    "title": "5  Some Examples",
    "section": "",
    "text": "5.1 Converting multiple columns to proportions\nlibrary(data.table)\n\ndt &lt;- data.table(\n  ID = 1:3,\n  var1 = c(2, 4, 1),\n  var2 = c(3, 1, 2),\n  var3 = c(5, 0, 3),\n  var4 = c(0, 2, 1),\n  var5 = c(0, 1, 3)\n)\n\ndt[, total := rowSums(.SD), .SDcols = var1:var5]\n\nvars &lt;- paste0(\"var\", 1:5)\ndt[, (vars) := lapply(.SD, function(x) x / total),\n    .SDcols = var1:var5][]\n\n      ID  var1  var2  var3  var4  var5 total\n   &lt;int&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt;\n1:     1   0.2 0.300   0.5  0.00 0.000    10\n2:     2   0.5 0.125   0.0  0.25 0.125     8\n3:     3   0.1 0.200   0.3  0.10 0.300    10\n\n# the following does not work\n# dt[, (var1:var5) := lapply(.SD, function(x) x / total),\n#    .SDcols = var1:var5]\n\n# this works\n# (new_dt &lt;- dt[, lapply(.SD, function(x) x / total),\n#   .SDcols = var1:var5, by = ID])",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Some Examples</span>"
    ]
  },
  {
    "objectID": "secondary_indices.html",
    "href": "secondary_indices.html",
    "title": "4  Secondary indices and auto indexing",
    "section": "",
    "text": "https://cran.r-project.org/web/packages/data.table/vignettes/datatable-secondary-indices-and-auto-indexing.html",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Secondary indices and auto indexing</span>"
    ]
  }
]